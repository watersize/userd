# userd — экспериментальный язык программирования

Это рабочий прототип интерпретируемого языка `userd` со следующими целями:

- Небольшая компактная реализация на Rust без внешних зависимостей.
- Простая, понятная синтаксис-структура (объявления переменных, функции `rtd`, классы и `self`).
- Встроенный REPL, CLI, GUI-хост (Windows) и минимальная поддержка упаковки/компиляции.

Этот README — подробное руководство по синтаксису, API и практическому использованию.

## Быстрый старт

Сборка и тесты (Windows PowerShell):

```powershell
cd example\userd
cargo test
```

Запуск REPL:

```powershell
cargo run -- repl
```

Запуск файла `script.usrd`:

```powershell
cargo run -- script.usrd
```

Упаковка в exe (appends script to current exe):

```powershell
cargo run -- pack script.usrd out.exe
```

Компиляция в артефакт `.usrdc` (проверка и запись встроенного источника):

```powershell
cargo run -- compile script.usrd out.usrdc
```

Запуск скомпилированного артефакта:

```powershell
cargo run -- out.usrdc
```

Пример запуска кода:

```powershell
cargo run --bin userd -- examples\gui_example.usrd
```

Также `userd` при запуске без аргументов пытается найти в собственном бинарнике встроенный скрипт (маркер `__USRDSCRIPT__`) и выполнить его.

## Синтаксис языка

- Объявление переменных: `тип-имя = выражение;` (тип сейчас только для читабельности, не строгая система типов)
- Функции: `rtd имя(параметры) { ... }`
- Классы: `class Имя { rtd __init__(self, ...) { ... } rtd метод(self, ...) { ... } }`
- Вызов функций: `имя(arg1, arg2)`
- Члены объекта: `obj.field` и `obj.method(args)`
- Выражения должны заканчиваться `;` в операторной позиции.

Примеры:

```
int-x = 5;
str-s = "hello";

rtd add(a,b) { a + b; }

class Point {
  rtd __init__(self, x, y) { self.x = x; self.y = y; }
  rtd move(self, dx, dy) { self.x = self.x + dx; self.y = self.y + dy; }
}

Point-p = Point(1,2);
p.move(3,4);

p.x;
```

## Встроенные функции и GUI API

Основные встроенные функции реализованы в VM:

- `get(prompt)` — чтение строки от пользователя (CLI)
- `to_int(x)`, `to_float(x)` — преобразования
- `apply_op(a,b,op)` — примитивные операции по коду (временный)
- GUI (Windows):
  - `gui_window(title, w, h)` — создаёт окно, возвращает id (int)
  - `gui_blit_b64(id, b64str, w, h)` — отправляет RGBA32 буфер, закодированный в base64
  - `draw_rect(id, canvas_w, canvas_h, x,y,w,h, r,g,b,a)` — рисует прямоугольник на холсте (создаёт буфер и пришлёт через blit)
  - `gui_button(id, label, handler_name)` — регистрирует кнопку (авто-позиционирование) и связывает её с функцией-обработчиком по имени
  - `gui_run()` — блокирующий цикл обработки GUI-событий пока есть открытые окна
  - `gui_poll()` — неблокирующий опрос и вызов обработчиков
  - `gui_message(title, message)` — показать простое сообщение (MessageBox)
  - `gui_close(id)` — закрыть окно

Пример GUI (см. `examples/user_example.usrd`): создание окна, генерация случайного цвета и отрисовка прямоугольника.

## Безопасный генератор случайных чисел

Добавлен встроенный `secure_random(max)`, возвращающий целое в диапазоне `[0, max)`.

- На Windows используется `BCryptGenRandom` из `bcrypt.dll`.
- На Unix-подобных системах читается `/dev/urandom`.

Используется метод rejection-sampling чтобы избежать схематичной модульной погрешности.

Пример:

```
int-n = secure_random(100); // 0..99
```

## Компиляция / артефакты

Команда `userd compile in.usrd out.usrdc` выполняет базовую валидацию (парсинг) и записывает артефакт `out.usrdc`, который содержит встроенный исходник (маркер `__USRDSRC__`). CLI умеет запускать `.usrdc` — оно просто извлекает встроенный источник и выполняет его интерпретатором. Это простой «компилятор-артефактор», достаточно чтобы распространять программы без отдельных исходников.

Также доступна команда `userd pack` — она создаёт самораспаковывающийся exe, дописывая скрипт к текущему бинарнику.

## Примеры

- `examples/user_example.usrd` — демонстрация GUI и secure_random.

## Как распространять и запускать .usrd файлы "в любом месте"

Если вы скачали бинарник `userd.exe`, вы можете:

1. Запустить скрипт напрямую: `userd.exe script.usrd`.
2. Скомпилировать в артефакт: `userd.exe compile script.usrd script.usrdc` и запускать `userd.exe script.usrdc`.
3. Упаковать скрипт в самораспаковывающийся exe: `userd.exe pack script.usrd out.exe` — полученный `out.exe` будет содержать скрипт и при запуске выполнит его.

## Важные заметки и дальнейшие шаги

- Это разработческий проект и многие части (оптимизация, безопасность GUI, полноценный компилятор в байткод/нативный код) пока в разработке.
- План следующих шагов: полноценный софтверный рендерер примитивов, сбор виджетов (textbox, scroll), запись/чтение артефактов с сериализацией AST/байткода и рефакторинг Win32-обёртки.

Если хотите, дальше я реализую:

- полноценный софтверный рендерер (`draw_text`, font bitmap) и механизмы перерисовки;
- более полноценный компилятор в байткод + VM-исполнитель байткода.

# userd — язык и интерпретатор

Кратко

userd — экспериментальный интерпретируемый объектно-ориентированный язык. Интерпретатор написан на Rust без внешних зависимостей (используется только std + нативные FFI для Win32 в платформенном слое). Проект содержит лексер, парсер, AST, VM, REPL и минимальные платформенные привязки для Windows (окна + отрисовка пиксельного буфера).

Файлы

- `src/` — реализация лексера, парсера, AST, VM и платформенных адаптеров.
- `examples/` — примеры программ на `.usrd`.
- `Cargo.toml` — манифест Rust.

Язык — синтаксис и семантика

Общая идея

- Все инструкции в языке должны заканчиваться точкой с запятой `;`.
- Объявление переменных — в форме `тип-имя = выражение;`. Сейчас `тип` используется как часть имени (например, `int-x = 5;`), строгой проверки типов нет — это метка для читаемости и дальнейшей типизации.
- Функции объявляются ключевым словом `rtd` (return): `rtd имя(параметры) { ... }`.
- Классы объявляются как `class Имя { ... }`. Методы внутри класса — это `rtd ...`. Первый параметр метода для доступа к экземпляру — `self`.
- Конструктор: метод с именем `__init__` вызывается автоматически при создании экземпляра.

Лексика (коротко)

- Идентификаторы: буквы, цифры и подчёркивания; не должны начинаться с цифры.
- Числа: целые (i64 в реализации).
- Числа: целые (i64) и с плавающей точкой (Float / f64) поддерживаются. Операции между Int и Float приводятся к Float при необходимости.
- Строки: в двойных кавычках (String).
- Логические значения: (будут добавлены позже) — пока можно моделировать через числа (0/1) или строки.
- Строки: в двойных кавычках.
- Разделители/операторы: `(`, `)`, `{`, `}`, `,`, `=`, `;`, `.` (точка — доступ к членам).
- Ключевые слова: `rtd`, `class`.

Примеры

1) Переменные и выражения

int-a = 10;
int-b = 20;
int-sum = a + b;
sum;

2) Функция

rtd sum(a,b) {
a + b;
}

int-res = sum(3,4);
res;

3) Класс и методы

class Point {
rtd __init__(self,x,y) { self.x = x; self.y = y; }
rtd move(self,dx,dy) { self.x = self.x + dx; self.y = self.y + dy; }
}
Point-p = Point(1,2);
p.move(3,4);
p.x; p.y;

4) REPL / ввод

get(prompt) — читать строку из stdin (возвращает string).
to_int(x) — парсит строку в целое.
to_float(x) — парсит строку в float.
apply_op(a,b,op) — примитивный оператор (1=+,2=-,3=*,4=/).

Встроенные GUI-функции (минимум)

- `gui_window(title, w, h)` — (Windows) создаёт окно и возвращает handle (int id).
- `gui_blit_b64(id, b64string, w, h)` — принимает base64-строку с сырыми байтами (ожидается 32-битный формат пикселя, RGBA) и отрисовывает её в окно с id.
- `gui_close(id)` — закрыть окно.
- `gui_message(title, text)` — показать сообщение (в Windows временно печать/MessageBox).
- `gui_button(win_id, label, handler_name)` — зарегистрировать обработчик нажатия (handler_name — имя функции в глобальной области). По умолчанию любой клик вызывает зарегистированный обработчик для данного окна.
- `gui_poll()` — однократно опрашивает очередь событий и вызывает зарегистрированные обработчики.
- `gui_run()` — блокирующий цикл: выполняет опрос событий и вызывает регистрационные обработчики до тех пор, пока открыты окна (удобно для демонстраций).

Принцип работы рантайма

- Лексер (`src/lexer.rs`) превращает код в токены.
- Парсер (`src/parser.rs`) строит AST (`src/ast.rs`).
- VM (`src/vm.rs`) выполняет AST: хранит глобальные переменные, стек вызовов, реализует вызовы функций/методов и объекты.
- Платформенный слой (`src/platform/*.rs`) реализует нативные окна/отрисовку; начальная реализация — Windows.

Как использовать обработчики GUI в `.usrd`:

1) Объявите функцию-обработчик (имя будет передано в `gui_button`):

rtd on_click(x,y) {
gui_message("Click", "You clicked!");
}

2) Создайте окно и зарегистрируйте обработчик:

id = gui_window("Hello", 300, 200);
gui_button(id, "Click me", "on_click");
gui_run();

`gui_run` выполнит цикл обработки событий и вызовет `on_click` при клике.

Пакетирование

- Команда `pack` в CLI позволяет упаковать `.usrd` скрипт внутрь интерпретатора: проект добавляет маркер и содержимое в бинарник; при запуске интерпретатор проверяет наличие маркера и автоматически выполняет встроенный скрипт.

Что за что отвечает (кратко)

- `lexer` — токенизация.
- `parser` — синтаксический разбор и построение AST.
- `vm` — выполнение, хранение значений и реализация встроенных функций.
- `platform` — нативные привязки (на данный момент Windows).

Дальнейшие планы

- Полная программная отрисовка (software renderer), виджеты (button, textbox), система событий и обработчиков в VM.
- Расширение синтаксиса (модули, import), улучшенная типизация и компиляция.
<<<<<<< HEAD

Авторские права / лицензия

- Репозиторий экспериментальный — добавьте лицензию, если планируете распространять.
=======
>>>>>>> 70c18529f47c392de088e2fd171a7b60df884bcf
